{"version":3,"sources":["../../../src/parse/tpdoc/definitions.js"],"names":["translateType","type","dependence","result","typeReal","trim","toLowerCase","test","reg","exec","groups","insideType","generic","mResult","push","concat","insideType2","generic2","getTypedefStrLine","refInfo","fields","parameteredEntityRefs","refLeadList","dependenceList","forEach","field","entityName","name","comment","typeResult","_comment","depend","refLead","join","getTypedefObj","ref","defStr","replace","definitionsParse","definitions","def"],"mappings":"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","sourcesContent":["import { uniqueArr } from '../utils';\n\nexport function translateType(type) {\n  if (!type) return { type: 'any', dependence: [] };\n  let result = type;\n  let dependence = [];\n  const typeReal = type.trim().toLowerCase();\n  switch (typeReal) {\n    case 'int':\n    case 'float':\n    case 'double':\n    case 'long':\n    case 'java.lang.long':\n    case 'java.lang.integer':\n    case 'java.lang.float':\n    case 'java.lang.double':\n      result = 'number';\n      break;\n    case 'java.lang.string':\n      result = 'String';\n      break;\n    case 'java.lang.boolean':\n      result = 'boolean';\n      break;\n    case 'java.lang.void':\n      result = 'void';\n      break;\n    default:\n      break;\n  }\n  if (/^java.util.List<(?<generic>.+)>/g.test(type)) {\n    const reg = /^java.util.List<(?<generic>.+)>/g.exec(type) || {};\n    if (reg.groups) {\n      const insideType = reg.groups.generic;\n      const mResult = translateType(insideType);\n      if (mResult.type === insideType) {\n        dependence.push(insideType);\n      }\n      dependence = dependence.concat(mResult.dependence);\n      result = `${mResult.type}[]`;\n    }\n  }\n\n  if (/^java.util.Map<(?<generic1>.+), (?<generic2>.+)>/g.test(type)) {\n    const reg = /^java.util.List<(?<generic>.+)>/g.exec(type) || {};\n    if (reg.groups) {\n      const insideType2 = reg.groups.generic2;\n      const mResult = translateType(insideType2);\n      if (mResult.type === insideType2) {\n        dependence.push(insideType2);\n      }\n      dependence = dependence.concat(mResult.dependence);\n      result = `Map<string, ${mResult.type}>`;\n    }\n  }\n  return { type: result, dependence };\n}\n\nfunction getTypedefStrLine(refInfo) {\n  if (!refInfo) return {};\n  const {\n    fields = [], parameteredEntityRefs = [],\n  } = refInfo;\n  const refLeadList = [];\n  let dependenceList = [];\n\n  fields.forEach((field) => {\n    const {\n      entityName,\n      name,\n      comment,\n    } = field;\n    const typeResult = translateType(entityName);\n    const _comment = comment ? ` ${comment.trim()}` : '';\n    refLeadList.push(` * @property {${typeResult.type}} ${name}${_comment}`);\n    if (entityName === typeResult.type) {\n      dependenceList.push(typeResult.type);\n    }\n    dependenceList = dependenceList.concat(typeResult.dependence);\n  });\n\n  parameteredEntityRefs.forEach((depend) => {\n    const {\n      entityName,\n    } = depend;\n    const name = entityName;\n    if (name === translateType(name).type) {\n      dependenceList.push(name);\n    }\n  });\n\n  return {\n    refLead: refLeadList.join('\\n'),\n    dependenceList,\n  };\n}\n\n/**\n * 获取引用的jsdoc字符串和依赖\n * @param {string} ref 引用的名称\n * @param {any} refInfo\n */\nfunction getTypedefObj(ref, refInfo) {\n  const {\n    refLead,\n    dependenceList,\n  } = getTypedefStrLine(refInfo);\n\n  if (!refLead) {\n    return null;\n  }\n\n  const comment = refInfo.comment ? ` ${refInfo.comment}` : '';\n\n  const defStr = `\n/**\n * @typedef ${ref.replace(/[<|>]/g, '_')}${comment}\n${refLead}\n */`;\n\n  return {\n    defStr,\n    dependenceList: uniqueArr(dependenceList),\n  };\n}\n\nexport function definitionsParse(definitions = []) {\n  const result = {};\n\n  definitions.forEach((def) => {\n    result[def.name.replace(/[<|>]/g, '_')] = getTypedefObj(def.name, def);\n  });\n  return result;\n}\n"],"file":"definitions.js"}